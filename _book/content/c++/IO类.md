# IO 类的基本内容

<img src ="../../resource/1.png">

- 从上图可以看出，iostream 是读写流[^1]，fstream 读写文件；从上图可以看出，fstream 继承于 iostream，因此发 fstream 也是读写流，只不过它的职责更窄，主要针对文件读写；
- cin 是标准输入流对象，cout 是标准输出流对象，这里的标准输入，就是指从键盘输入，标准输出，就是指输出到终端，由于 c++中继承机制的实现，使我们不用考虑设备类型和字符大小的问题；
- c++的输入与输出包括以下三个部分：
  1. 对系统制定的标准设备的输入和输出，称为标准 I/O（设备）;
  2. 以磁盘文件为对象进行输入和输出，称为文件 I/O（文件）;
  3. 对内存中指定的空间进行输入和输出，称为串 I/O（内存）;

## 关于流的条件状态

&emsp;&emsp;一个流一旦发生错误，那么其后续的 IO 操作都会失败，只有一个流处于无错误状态时，我们才可以对其进行读写操作，因此代码应该在使用一个流之前检查它是否处于良好状态，代码如下：

```c++
while(cin >> word)
    //ok: 读操作成功,否则 >>返回false
```

&emsp;&emsp;上面只是告诉了我们流是否有效，例如一个流失败了，我们不知道为什么失败，关于这一部分，我们可以使用 iostate[^2], 也可以使用 stream.eof()等函数判断；

## 关于缓冲区

- 每个输出流都有一个缓冲区，用来保存程序读写的数据，如果我们执行文本打印操作，那么文本可能立即打印，也可能不立即打印，此时文本就被保存到了缓冲区；
- 文本缓冲区之所以存在，是因为设备的读写操作可能都很耗时，允许操作系统将多个输出操作合二为一可以带来性能提升；
- 如果我们不想使用缓冲，那么就必须进行缓冲刷新，以下方式可以导致刷新：
  > 1. 程序正常结束；
  > 2. 缓冲区满时；
  > 3. 使用操作符 endl；
  > 4. 使用 flush；

Note：如果程序崩溃，那么输出缓冲区是不会被刷新的，可能存在这样一种情况：我们通过输出调试信息调试程序，但程序正好崩溃，但实际输出可能已经执行，之所以没有打印只是因为没有缓冲区没有被刷新而已；

## 文件输入输出

&emsp;&emsp;ifstream、ofstream 都继承自 fstream，分别对应标准输入输出流中的 cin、cout，cin 是以键盘作为作为标准输入，ifstream 是以文件作为输入，换句话说，就是读取文件；同理，cout 是以终端作为标准输出，ofstream 是以文件作为输出，也就是把数据写入文件;<a href = "https://github.com/JKLcoder/study/blob/master/C%2B%2B/C%2B%2B_Code/base/src/test_8.cpp">代码链接</a>

## 文件模式

<img src= "../../resource/QQ截图20200528220242.png"><br>
&emsp;&emsp;在使用过程中，文件模式需要注意一下几点：

1. 只可以对 ofstream 和 fstream 设定 out 模式，只可以对 ifstream 和 fstream 设定 in 模式，那么如果我们需要同时对文件进行镀锡，需要创建 fstream 对象；
2. 当写文件时，文件默认为 trunc 模式，文件一旦打开，就会立即清空，如果我们想要追加数据，而不是覆盖，那么需要同时制定 app 模式，这样数据会被追加到文件末尾；

# 编写自己的输入输出运算法（14 章）

# 控制输出格式以及文件的随机访问（17 章）

[^1]：流是 c++中的抽象概念，我们可以认为流就是对象，如果从标准输出输入流中读写数据那么也就意味着从 cout、cin 中读写数据；
[^2]：iostate 是一个机器无关类，提供了表达流状态的完整功能；

参考链接：<a href = "https://www.cnblogs.com/tianzeng/p/9038810.html">C++的流</a>
