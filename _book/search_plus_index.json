{"./":{"url":"./","title":"Introduction","keywords":"","body":"  君子曰：学不可以已。   青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。   故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。   吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。   南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。   物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蜹聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！   积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。   是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，鼫鼠五技而穷。《诗》曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮！”故君子结于一也。   昔者瓠巴鼓瑟，而流鱼出听；伯牙鼓琴，而六马仰秣。故声无小而不闻，行无隐而不形 。玉在山而草木润，渊生珠而崖不枯。为善不积邪？安有不闻者乎？   学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人， 真积力久则入，学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之，人也；舍 之，禽兽也。故书者，政事之纪也；诗者，中声之所止也；礼者，法之大分，类之纲纪也。 故学至乎礼而止矣。夫是之谓道德之极。礼之敬文也，乐之中和也，诗书之博也，春秋之微 也，在天地之间者毕矣。 君子之学也，入乎耳，着乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口；口耳之间，则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲、非也，囋、非也；君子如向矣。   学莫便乎近其人。礼乐法而不说，诗书故而不切，春秋约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。   学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺诗书而已耳。则末世穷年，不免为陋儒而已。将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以诗书为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。   问楛者，勿告也；告楛者，勿问也；说楛者，勿听也。有争气者，勿与辩也。故必由其道至，然后接之；非其道则避之。故礼恭，而后可与言道之方；辞顺，而后可与言道之理；色从而后可与言道之致。故未可与言而言，谓之傲；可与言而不言，谓之隐；不观气色而言，谓瞽。故君子不傲、不隐、不瞽，谨顺其身。诗曰：“匪交匪舒，天子所予。”此之谓也。   百发失一，不足谓善射；千里蹞步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀纣盗跖也；全之尽之，然后学者也。   君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使耳非是无欲闻也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。 "},"content/c++/C++中概念对比.html":{"url":"content/c++/C++中概念对比.html","title":"C++中概念对比","keywords":"","body":"指针与引用的区别 指针是一个对象，而引用是别名，没有空间； 引用必须被初始化，但指针不用； 指针可以修改指向，但是引用不可以； 指针可以指向空，但是引用不可以； sizeof 引用我们获得的是所指向对象的大小，而 sizeof 指针得到的则是指针本身的大小； 内联函数与函数的对比 调用函数一般比较慢：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参； 内联函数避免了函数调用的开销，它将在编译过程中在每个调用点内敛地展开； 总结：如果函数规模较小、流程直接、调用频繁，那么内联函数更好；反之，如果函数规模过大，如果使用内联函数反而会增大 exe 体积，这种情况则应该使用普通函数； struct 和 class 的区别 struct 再第一个访问说明符之前的成员是 public，而 class 再第一个访问说明符之前的成员则是 private； "},"content/c++/IO类.html":{"url":"content/c++/IO类.html","title":"IO类","keywords":"","body":"IO 类的基本内容 从上图可以看出，iostream 是读写流1，fstream 读写文件；从上图可以看出，fstream 继承于 iostream，因此发 fstream 也是读写流，只不过它的职责更窄，主要针对文件读写； cin 是标准输入流对象，cout 是标准输出流对象，这里的标准输入，就是指从键盘输入，标准输出，就是指输出到终端，由于 c++中继承机制的实现，使我们不用考虑设备类型和字符大小的问题； c++的输入与输出包括以下三个部分： 对系统制定的标准设备的输入和输出，称为标准 I/O（设备）; 以磁盘文件为对象进行输入和输出，称为文件 I/O（文件）; 对内存中指定的空间进行输入和输出，称为串 I/O（内存）; 关于流的条件状态   一个流一旦发生错误，那么其后续的 IO 操作都会失败，只有一个流处于无错误状态时，我们才可以对其进行读写操作，因此代码应该在使用一个流之前检查它是否处于良好状态，代码如下： while(cin >> word) //ok: 读操作成功,否则 >>返回false   上面只是告诉了我们流是否有效，例如一个流失败了，我们不知道为什么失败，关于这一部分，我们可以使用 iostate2, 也可以使用 stream.eof()等函数判断； 关于缓冲区 每个输出流都有一个缓冲区，用来保存程序读写的数据，如果我们执行文本打印操作，那么文本可能立即打印，也可能不立即打印，此时文本就被保存到了缓冲区； 文本缓冲区之所以存在，是因为设备的读写操作可能都很耗时，允许操作系统将多个输出操作合二为一可以带来性能提升； 如果我们不想使用缓冲，那么就必须进行缓冲刷新，以下方式可以导致刷新： 程序正常结束； 缓冲区满时； 使用操作符 endl； 使用 flush； Note：如果程序崩溃，那么输出缓冲区是不会被刷新的，可能存在这样一种情况：我们通过输出调试信息调试程序，但程序正好崩溃，但实际输出可能已经执行，之所以没有打印只是因为没有缓冲区没有被刷新而已； 文件输入输出   ifstream、ofstream 都继承自 fstream，分别对应标准输入输出流中的 cin、cout，cin 是以键盘作为作为标准输入，ifstream 是以文件作为输入，换句话说，就是读取文件；同理，cout 是以终端作为标准输出，ofstream 是以文件作为输出，也就是把数据写入文件;代码链接 文件模式   在使用过程中，文件模式需要注意一下几点： 只可以对 ofstream 和 fstream 设定 out 模式，只可以对 ifstream 和 fstream 设定 in 模式，那么如果我们需要同时对文件进行镀锡，需要创建 fstream 对象； 当写文件时，文件默认为 trunc 模式，文件一旦打开，就会立即清空，如果我们想要追加数据，而不是覆盖，那么需要同时制定 app 模式，这样数据会被追加到文件末尾； 编写自己的输入输出运算法（14 章） 控制输出格式以及文件的随机访问（17 章） 1：流是 c++中的抽象概念，我们可以认为流就是对象，如果从标准输出输入流中读写数据那么也就意味着从 cout、cin 中读写数据； 2：iostate 是一个机器无关类，提供了表达流状态的完整功能； 参考链接：C++的流 "},"content/c++/关于数组.html":{"url":"content/c++/关于数组.html","title":"关于数组","keywords":"","body":"数组声明 数组声明时，我们可以指定其大小，也可以不指定，但后一种情况必须初始化，编译器通过初始化可以确认该数组大小; int a[10] = {1,2,3,4,5}; //正确，数组大小是10 int a[] = {1,2,3,4,5}; //正确，数组大小是5 int a[10]; //正确，数组大小是10 int a[]; //错误，无法确定数组大小 数组大小 int a[] = { 0,1,2,3,4,5,6,7,8,9,2,3,4,5,6}; int x = sizeof(a) / sizeof(a[0]); 数组形参 当数组作为形参时，有两个特殊的性质：不允许拷贝数组、数组将会转化为指针，这也就意味着：当数组已经作为形参传入函数后，已经不能再使用上述sizeof函数的方式来计算数组元素个数了；那么我们此时就必须考虑元素个数的传入问题； void print(const int*);//正确，但无法获知当前数组的元素个数 void print(const int[]);//正确，但无法获知当前数组的元素个数 void print(const int[10]);//正确，同时我们知道了当前数组元素个数为10，但是针对元素个数不为10的数组无法适用 void print(const int*,int n);//这种似乎是最佳方式，适用于任何大小的数组 void print(const int[],int n);//同上 数组作为形参时实际是一个指针，那么如果const修饰该指针那么也就是一个底层const，即无法修改数组中元素； 返回数组 返回指针并不困难，因为指针指向某个地址，地址中存储某个value，但是返回数组却略有不同，因为数组v有大小，那么返回时我们必须考虑同时返回数组的大小，此外，数组不允许拷贝，也就是说我们必须返回数组的指针，这两者导致了在实际操作上存在困难；但是C++还是提供了相应方案，主要分为以下三种： 使用类型别名； 声明一个返回数组指针的函数 使用尾置返回类型 使用decltype 参考代码 "},"content/c++/关键字const.html":{"url":"content/c++/关键字const.html","title":"关键字const","keywords":"","body":" 默认状态下，const 对象仅在文件内有效，这和非 const 对象存在很大不同，也就意味着：如果我们在头文件中包含了一个非 cosnt 对象，当该头文件被多个文件包含时，将会报出重复定义的错误，但是 const 对象则不会，我们可以默认其为 static 对象； 当我们需要多个文件共享同一 const 变量时，使用头文件固然可以，但更好的做法是：我们在一个文件中定义，而在其它文件中声明；需要注意的是，这里和非 const 变量也存在不同：非 const 变量只需要在声明时添加 extern 关键字即可，但是 const 变量则不管是声明还是定义都要田间 extern 关键字，我们可以这样理解：在默认 const 变量为 static 变量的情况下，我们必须在定义时添加 extern 关键字才能为其增加外部引用性； const 引用及指针不要求其所指向的对象一定是一个常量，其含义仅限于不能通过该指针及引用去改变对象，但是可以通过其它途径； 我们需要区别指针指向常量对象及常量指针，指针指向常量对象意味着不能通过该指针去修改其指向的对象的值，但是可以修改该指针的指向；常量指针则意味着该指针不能修改该指针指向，但是可以通过该指针去修改其所指向对象的值； int a = 23; int b = 34; const int *p1 = &a; //指针指向常量对象 int *const p2 = &b; //常量指针 //修改指向常量的指针指向 p1 = &b; //修改指向常量的指针的值 //*p1 = 24; //报错：assignment of read-only location '* p1' //修改常量指针的指向 //p2 = &a; //报错：assignment of read-only variable 'p2' //修改常量指针的值 *p2 = 33; 顶层 const 表示指针本身就是个常量，而底层 const 表示指针所指向的是一个常量，更一般地说，顶层 const 可以表示任意的对象是常量，而底层 const 只存在于指针及引用当中。指针包含了顶层 const 和底层 const，引用的 const 都是底层 const，至于其它的类型则都是顶层 const；对于顶层 const，其拷贝没有任何影响，也就是说：我们可以把一个顶层 const 变量拷贝给一个非 const 变量，反之亦可；但是底层 const 变量则对此有严格限制：非常量可以拷贝给 const 变量，反之则不行； "},"content/c++/函数传参.html":{"url":"content/c++/函数传参.html","title":"函数传参","keywords":"","body":"    函数传参主要分为两种形式：值传递与地址传递；值传递本质上是拷贝，所以无法修改形参；而地址传递传递的是形参本身的地址，因此可以修改形参； 数组传参     数组名其本质是数组的首地址，当我们把数组作为参数传递时，此时属于地址传递； 指针传参     指针传参需要注意的是：指针本身可以视作对象，如果我们要修改其指向，那么就必须进行地址传递，对于指针来说，其地址即对应的二级指针； 可变形参     可变形参主要可以通过两种方式实现： initializer_list 可变参数模板     这两种方式实现可变形参的区别在于：前者必须形参类型都相同，我们可以将其等价于list，只不过与list相比，其缺乏at、[]等访问接口；而可变参数模板则突破了前者这种限制，只不过使用上要稍微复杂一点； 参考代码1参考代码2 "},"content/c++/函数指针.html":{"url":"content/c++/函数指针.html","title":"函数指针","keywords":"","body":"普通函数指针 函数指针声明 bool lengthCompare(const string&, const string&); bool (*pf)(const string& , const string&) = lengthCompare; pf = lengthCompare; pf = &lengthCompare; bool b = pf(\"hello\", \"goodBye\"); bool b = (*pf)(\"hello\", \"goodBye\"); 注意： 此时的pf表示这是一个函数指针，而非函数指针类型,如果要表示指针类型需要使用指针别名（见下）； 当我们把函数名作为一个值使用时，该函数自动转换为指针； 当我们使用函数指针调用该函数时，无需提前解引用指针； 使用指针别名 typedef bool(*Func)(const string&,const string&); typedef decltype(lengthCompare) *Func; using Func = bool(*)(const string&,const string&); void useBigger(const string& s1, const string& s2, Func f); //将函数指针作为形参 Func f(int); //将函数指针作为返回值 decltype自动类型推导函数后还是函数，一定要加* 使用using定义别名时要注意和typedef存在的区别 尽量定义函数指针别名后再使用函数指针形参及返回，否则会降低代码的可读性 类函数指针 参考代码 使用std::function 和std::bind "},"content/c++/实现引用计数.html":{"url":"content/c++/实现引用计数.html","title":"实现引用计数","keywords":"","body":"  在智能指针中，我们已经学习了智能指针，如果要实现引用计数，直接使用智能指针 shared_ptr 即可，但是为了对引用计数这种行为更加深刻的了解，我们可以实现自定义类，完成引用计数功能；   引用计数的工作方式如下： 构造函数（不包括拷贝构造函数）需要创建一个引用计数，用于记录当前有多少个对象与正在创建的对象共享状态，此时计数初始化为 1； 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，计数器使用浅拷贝； 析构函数递减计数器，计数器减 1，当计数器变为 0 时，析构函数释放空间； 拷贝赋值运算符递增右侧对象的计数器，递减左侧运算对象的计数器，如果左侧运算对象的计数器变为 0，那么就要销毁；   参考代码   上面的参考代码只是一个引用计数实现的简单版本，虽然也可以实现引用计数，但是和 shared_ptr 还是存在一定区别: 未实现类模板 shared_ptr 的引用计数实际是使用基类指针完成； "},"content/c++/智能指针.html":{"url":"content/c++/智能指针.html","title":"智能指针","keywords":"","body":"  智能指针用于管理动态内存，当智能指针过期时，这些内存将自动释放；智能指针也是模板，当我们创建智能指针时，需要提供其所指向的类型；   可以从 auto_ptr 的构造函数来了解一下智能指针的基本构成： template class atuo_ptr{ public: explicit auto_ptr(X* p=0) throw; }   从上面可以看出，智能指针中保存了一个指针成员，在构造函数中传入赋值；目前 auto_ptr 已经被弃用，主要原因在于：当 auto_ptr 进行赋值时，将会进行所有权转让，但是失去所有权的指针将不再指向有效数据，如果此时还要使用该指针就会出现问题； shared_ptr   shared _ptr 允许多个指针指向同一个对象；其基本原理是：使用引用计数，赋值时，计数将加 1，指针过期时，计数将减 1，当最后一个指针过期时，才调用指针成员的析构函数进行析构；  指向相同资源的所有 shared _ptr 共享“引用计数管理区域”，并采用原子操作保证该区域中的引用计数被互斥的访问，该“引用计数管理区域”由其基类指针指向它，当我们进行 shared _ptr 的拷贝时，我们可以认为该基类指针使用的是一种浅拷贝，也就是无论拷贝多少次，“引用计数管理区域”都不会被重新创建，而是引用计数增 use _count _增 1，反之 use _count _减 1；(参考链接) shared_ptr 的拷贝构造函数与赋值运算符 shared_ptr p(new T()); shared_ptr q(new T()); p = q; //#3 shared_ptr p1(p); //#4   除了析构函数之外，shared_ptr 的拷贝构造函数与赋值运算符也将影响当前对象的引用计数，考虑上面代码将会带来什么效果；  拷贝构造函数(#4)将会增加 p 所指向对象的引用计数；赋值运算符（#3）可以视作 q 所指向的对象对 q 所指向的对象进行了覆盖，所以此操作会递减 p 所指向对象的引用计数，而会递增 q 的引用计数； unique_ptr   在同一时刻只能有一个 unique_ptr 指向给定对象，当我们进行赋值时会进行所有权让，所以 unique_ptr 和 auto_ptr 比较类似，但是如果只是如此，那么将无法避免 auto_ptr 的缺陷，所以 unique_ptr 对此进行了修正：当程序试图将一个 unique_ptr 赋给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这样做，但是如果 unique_ptr 将存在一段时间，编译器将禁止这么做； unique_ptr p3(new string(\"auto\")); unique_ptr p4; p4 = p3; //#6   编译器会认为#6 非法，避免了 p3 不再指向有效数据的问题； unique_ptr demo(const char* s) { unique_ptr temp(new string(s)); return temp; } unique_ptr ps; ps = demo(\"Uniquely special\");   上述操作允许，因为 ps 接管了所有权，而原有 unique_ptr 对象被销毁了； weak_ptr   weak_ptr 是一种弱引用，指向 shared_ptr 所管理的对象；将一个 weak_ptr 绑定到一个 share_ptr 不会改变 shared_ptr 的引用计数，一旦最后一个指向对象的 share_ptr 被销毁，对象就会被释放，即使有 weak_ptr 指向对象，对象还是会被释放，因此它是一种弱共享； 我们可以像下面这样使用 weak_ptr： auto p = make_shared(43); weak_ptr wp(p); if(shared_ptr np = wp.lock()) { ... }   需要注意的是：我们不能使用 weak_ptr 直接访问对象，因为 weak_ptr 并没有重载 operator->和 operator *操作符，因此不可直接通过 weak_ptr 使用对象，典型的用法是调用其 lock 函数来获得 shared_ptr 示例，进而访问原始对象;   同时由于 weak_ptr 所指向的对象有可能不存在，因此上述代码使用了 lock，该函数的作用是：如果其所指向的 shared_ptr 对象存在，那么我们就返回 wp 所指向的 shared_ptr 对象，否则返回一个空 shared_ptr;   那么 weak_ptr 到底有什么用呢？从上面我们可以看出，使用 weak_ptr 是通过间接调用 share_ptr,那么为什么不直接使用 share_ptr 就好了呢？   weak_ptr 是为了解决 shared_ptr 存在的环形引用问题； class Parent { public: shared_ptr child; } class Child { public: shared_ptr parent; } shared_ptr pA(new Parent); shared_ptr pB(new Child); pA->child = pB; pB->parent = pA;   上述代码将会存在这样一个困境：两个对象各自包含指向彼此的 shared_ptr 成员，形成环状引用，引用计数永远为 1，不能销毁，造成内存泄漏；   如果我们将上述代码中的类成员的 shared_ptr 使用 weak_ptr 代替，即如下所示： class Parent { public: weak_ptr child; } class Child { public: weak_ptr parent; } shared_ptr pA(new Parent); shared_ptr pB(new Child); pA->child = pB; pB->parent = pA;   那么根据 weak_ptr 的特性，其不会增加 shared_ptr 的引用计数，从而打破了 shared_ptr 的环状引用问题； 智能指针与常规指针的区别   智能指针和常规指针确实很类似，但是还是存在一定区别，例如： shared_ptr p = new string();   上述赋值并不能成立，因为 p 是智能指针，而非指针，智能指针中包含指针成员，只能通过其构造函数来初始化，当没有初始化时，该指针指向空； 智能指针的选择 如果程序要使用多个指向同一个对象的指针，那么应选择 shared_ptr;这样的情况包括：有一个指针数组，并使用一些辅助指针来标识特定的元素，如最大的元素和最小的元素；两个对象对包含指向第三个对象的指针：STL 容器包含的指针； 如果程序不需要多个指向同一个对象的指针，可以使用 unique_ptr,如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是一个不错的选择； "},"content/c++/类的组成.html":{"url":"content/c++/类的组成.html","title":"类的组成","keywords":"","body":"默认构造函数 如果我们没有显式的定义构造函数，那么编译器将会创建一个默认的构造函数；一旦我们定义了任何构造函数，那么除非我们再定义一个默认构造函数，否则该类讲没有默认构造函数; 默认构造函数与自定义的构造函数似乎没有什么不同，但是实际上还是存在区别，例如类中包含有数组和指针，默认构造函数将会导致野指针等类似问题，此时需要自定义默认构造函数再内部控制对象初始化；这种情况同样可以扩大到类中，如果该类包含其它类，但是其他类没有默认构造函数，为了完成其他类的初始化，那么为该类自定义默认构造函数同样必不可少； 析构函数 C++中的 new 相当于 C 语言中的 malloc，如果我们分配一个对象那么就用 new char[], 如果要分配一组对象那么就要用 new char[n]；但是需要注意的是，前者可以用 delete m_data, 也可以用 delete [ ]释放空间，但是后者只能用 delete [ ]释放空间，如果用 delete 释放 new [ ]分配的空间，那么将会只释放第一个，从而导致内存泄漏；基于上述原因，所以我们一律使用 delete[ ]在析构函数中释放分配的空间； 拷贝构造函数 拷贝构造函数分浅拷贝与深拷贝：浅拷贝仅复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，而深拷贝会另外创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会修改原对象；如果一个类里有指针，那么则必须对该指针进行深拷贝，反之，浅拷贝即可满足条件； 拷贝构造函数和拷贝赋值运算符存在的不同在于：其空间本身是不存在的，所以我们无须考虑其原有空间的处理； 拷贝赋值运算符 赋值函数返回引用；当我们给一个值赋值时，只有返回其本身引用才有意义，否则如果返回一个新的变量，那么将会毫无意义； 自我判断；赋值时无法避免把自己赋给自己，所以必须在函数内部加以判断； 释放原有空间，分配新的空间 ；为什么不在原有空间上赋值，而必须销毁之前的，再创建一个新的呢？首先无法确保原有空间是否足够，其次就算足够那么我们也会浪费空间； 运算符重载 为什么在可以使用类成员函数进行运算符重载的情况下，还要使用友元函数进行运算符重载，这是因为可能存在下列情况：A = B*2.75; 那么这个对应的是 A = B.operaotr*(2.75); 那么反过来呢？A=2.75*B；由于 2.75 并非对象，那么这种情况就无法成立，在此基础上，所以需要使用友元函数进行运算符重载；针对 A=2.75*B 就可以和 class1 operator*(double m，const class1 &t)进行匹配；对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。 友元函数 友元函数需要注意他的作用域；如果一个友元函数在类中声明，在类外定义，那么这种情况是没有问题的；但是如果一个友元函数在类中定义呢？那么此时友元函数变成了一个内联函数，但是需要注意的是，由于此时其在外部未被声明，那么无论在类内部还是外部都不能被调用； struct X{ friend void f(){} X(f(); ) //错误：f还没有被声明 void g(); void h(); }; void X::g(){return f(); } //错误：f还没有被声明 void f(); void X:h(){return f(); } //正确，f已经被声明了 友元类 友元类可以类比友元函数，一个类的友元类可以访问此类中包括非公有成员在内的所有成员； class Screen{ friend class Window_mgr; } 三五法则   三五法则规定了什么时候需要拷贝构造函数、拷贝赋值运算符以及析构函数； 需要析构函数的类也需要拷贝和赋值操作；如果一个类包含指针成员，那么其必然需要析构函数，基于同样的理由，也必须要提供拷贝和赋值操作以进行深拷贝； 需要拷贝操作的也需要赋值操作，反之亦然； 阻止拷贝   在某些情况下我们可能需要防止类被拷贝，但是不定义拷贝控制成员也是无用的，因为编译器会生成默认版本，如果要防止拷贝主要有以下两种方式； 定义删除的函数   在 c++11 标准中，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝；删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们，在函数的参数列表后面加上=delete 来指出我们希望将它定义为删除的； struct NoCopy{ NoCopy() = default; NoCopy(const NoCopy&) = delete; NoCopy &operator=(const NoCopy&) = delete; ~NoCopy() = default; }   =delete 通知编译器我们不希望定义这些成员； private 拷贝控制   我们也可以通过将拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝； class PrivateCopy{ PrivateCopy(const PrivateCopy&); PrivateCopy &operator=(const PrivateCopy&); public: PrivateCopy() = default; ~PrivateCopy(); } 参考代码 "},"content/Eigen/Eigen使用过程中问题集锦.html":{"url":"content/Eigen/Eigen使用过程中问题集锦.html","title":"Eigen使用过程中问题集锦","keywords":"","body":"Eigen的使用时遇到error C2338: INVALID_MATRIX_PRODUCT问题解决 "},"content/Eigen/Eigen的基本使用.html":{"url":"content/Eigen/Eigen的基本使用.html","title":"Eigen的基本使用","keywords":"","body":""},"content/JavaScript/JavaScript基础知识.html":{"url":"content/JavaScript/JavaScript基础知识.html","title":"JavaScript基础知识","keywords":"","body":""},"content/Qt/Qt中异常问题集锦.html":{"url":"content/Qt/Qt中异常问题集锦.html","title":"Qt中异常问题集锦","keywords":"","body":"中文读写乱码   设置本地编码为 utf-8 即可，如下： QTextCodec::setCodecForLocale(QTextCodec::codecForName(\"Utf-8\")); "},"content/Qt/Qt代码片段集锦.html":{"url":"content/Qt/Qt代码片段集锦.html","title":"Qt代码片段集锦","keywords":"","body":"递归遍历目录 //参数含义（当前遍历目录、当前遍历目录上一级目录name、记录当前目录相对于顶级父目录深度） bool reverseDir(const QDir& dir,QString parentName,int parentLevel) { QString dirname = parentName + QString(\"%1/\").arg(dir.dirName()); parentLevel++; QFileInfoList list = dir.entryInfoList(); for(QFileInfo &info : list) { //在Qt10.1中发现，如果不过滤将会有这两个目录，可以认为是父目录和二级父目录，如果遍历当前目录则必须过滤掉 if(!QString::compare(info.fileName(),\".\") || !QString::compare(info.fileName(),\"..\")) continue; if(info.isDir()) //当前为目录 { ... reverseDir(QDir(info.filePath()),dirname,parentLevel,in); } else //当前为文件 { ... } } return 1; } "},"content/tools/2020-05-25-hexo框架blog的建立.html":{"url":"content/tools/2020-05-25-hexo框架blog的建立.html","title":"2020-05-25-hexo框架blog的建立","keywords":"","body":"    之前使用过 csdn 写过 blog，但是之前自己糟糕的排版，渐渐打消了我坚持下去的动力，直到最近，开始使用 vscode，然后又学了一下 markdown，才让我产生了重新开始写 blog 的想法；    一开始选用了 Jekyll，但是 Jekyll 框架下实在很难找到一个吸引人的主题，之前做了一个，但感觉实在很一般，于是开始使用 hexo；    配置 hexo 的过程实在不是一个开心的过程，差不过花了一整天，一个周末，就这样莫名其妙的过去了一大半，所以我觉得有必要整理一下自己在这个过程中的探索； 创建 github page Repositories     创建一个 Repositories，必须是 username.github.io 的形式，username 是你的 github 账号用户名，主要起到 github pages 部署 blog 时的识别作用；     然后选择 Repositories 对应的 settings，选择 Choose a theme, 在这一步我们可以下载一个初始的主题，验证一下是否 github pages 已经发布成功！ 生成 SSH 添加到 Github     这一步主要是针对 github 新手而言，以下操作都在 git bash 完成： 设置电脑要关联的 github 账号 git config --global user.name \"yourname\" git config --global user.email \"youremail\" 验证是否设置正确 git config user.name git config user.email 创建 ssh，一路回车 ssh-keygen -t rsa -C \"youremail\"     一般会生成两个文件，id-rsa 和 id_rsa.pub，你只需要把 id_rsa.pub 中的内容加入到 github 账号中去就可以了，具体做法是：登录 web 端的 github 账号后，点击 settings -> SSH keys -> New SSH key, 把 id_rsa.pub 中的内容复制进去即可； 验证是否成功 ssh -T git@github.com     为什么需要 ssh 呢？简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。对于初次在当前电脑使用 github 同步代码，这一步必不可少； Hexo 安装     Hexo 建站当然需要安装 Hexo，要安装 Hexo 那么首先又要安装 npm1，而安装 npm 通常我们通常通过安装 Node.js 环境安装，至于 Node.js 环境安装网上资料多如牛毛，这里就不再具体介绍；以下操作均在终端中进行； npm install -g hexo-cli     这里的-g 是指全局安装，一般情况下，我们在安装了 Node.js 之后，需要设置一个全局安装路径：所有使用 npm 下载的软件包都会下到该路径下，同时该路径也需要加入到环境变量中，这样无论在任一路径下，打开终端，我们都可以使用相应命令； Hexo 建站     在想要建站的目录，打开终端，进行以下操作： hexo init npm install     第一条命令用于建站文件初始化，第二条用于根据 package.json 文件下载建站相关依赖文件； 完成上述操作后，我们基本上就应经获取了就已经获取了如下目录: . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes     _config.yml 用于站点各种信息配置，我们可以在链接中获取详细信息，这里不再赘述；     _post 文件是我们用于存储需要发布 md 文件的目录；     themes 用于存储我们的主题，对于 Hexo 来说，next 模板可能是最常用的了吧，我们只需要下载一套 next 模板，然后放入 thems 目录，同时修改_config.yml 中为 theme: next 即可；     在完成上述操作的情况下，我们基本上已经可以预览一下网站效果了，如果只是预览，那么可以使用： Hexo server     如果想使用调试模式，那么使用： Hexo s --debug     在前述步骤完全配置成功的情况下，那么我们将会看到： INFO Hexo is running at http://localhost:4000 ;     点击对应网址，即可看到效果了； next 模板     关于 next 模板使用的大部分技巧，在这个链接中都可以找到答案，但是这里面提供的 next 下载模板虽然自由度比较大，但是对于那些并不擅长前段开发的人来说，想要快速使用，同时又要保证效果尚佳的人来说，还是有一定难度，所以我推荐使用在 next 模板上已经进行一定程度开发的成熟模板，对于程序员来说这也是一种可以接受的做法：尽量找轮子，而非造轮子；     这是我使用的模板，这个哥们效果做的还是很丰富的，以至于我不得不屏蔽了部分效果；     需要注意的是，对于 next 模板中的大部分文件，我们都是不需要操作的，我们所有需要修改的都可以在该目录下的_config.yml 中完成；     但是也可能存在一些问题，下面是我碰到的一些，以及我所找到的解决方案： 在 next 配置文件中，选择了一些菜单项，例如分类、标签，但是在预览时，点击菜单异常；解决方案 next 模板的网站访问过慢！解决方案 Hexo 部署到 github pages     这里体现了 Jekyll 和 Hexo 一个很大的不同：前者其站点的基础建站文件和 github page 对应的仓库文件是一样的，我们甚至可以修好 md 后直接放到其_post 目录，刷新网页即可看到更新；后者 github page 对应仓库的文件实际是建站文件经过 hexo 编译后上传的文件；     所以对于 Hexo，建议使用两个仓库，一个用于发布 Github pages，另一个则用于同步基础的建站文件，每次建站仓库部署后发布到前者上面；     所以，对于 Hexo 部署，是必不可少的重要一步，操作流程如下： 安装 hexo-deployer-git 部署工具； $ npm install hexo-deployer-git --save     只要执行过一次即可； 修改建站文件中的_config.yml; deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master     要注意，一般必须要求在主分支部署； 部署； hexo clean hexo generate hexo deploy     其中 hexo clean 清除了你之前生成的东西，也可以不加。     hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写；     hexo deploy 部署文章，可以用 hexo d 缩写；     注意 deploy 时可能要你输入 username 和 password，目前发现输慢了可能导致部署失败，所以手速很重要；需要注意的是，该操作尽量在 git bash 中进行，因为 git bash 已经登录了 github 账号，所以要求输入账号密码的可能性不大，如果使用其他终端，则基本上每次都需要输入；     这个步骤在我们每次有新文章同步到 blog 中都需要执行，但是也可以使用简化版： hexo d -g     此时我们可以不用 hexo clean，hexo d -g 会识别增量渲染，不会全部重新生成，感觉更安全一点； 关于 hexo 中的其他问题 hexo 中 markdown 的语法区别； 使用```标记代码块时，后面一个不要加空格，否则代码块范围会识别错误，同时代码最好顶格处理，否则可能会莫名其妙的对不齐； 写脚注时，[^1]：中的冒号必须是中文的，否则显示异常； 在 hexo 中显示图片；     _config.yml 中设置： post_asset_folder: true     使用下述命令创建文章： hexo new [layout]     则会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。这一步也可以手动完成，之后把我们的图片资源放在这个目录下；     使用下述方式引用图片资源： {\\% asset_img 1.jpg \\%}     然后我们就能在 blog 中看到图片的正常显示了；     需要注意的是：这里并不需要我们把资源目录也加进去，因为 hexo 会把这些文件编译后部署到 github pages，如果我们打开目录将会发现图片已经和生成的对应 html 放在同一目录下了； 参考：链接 1 1. 软件包管理器，用于下载一些软件包, 包括 Hexo； ↩ "},"content/tools/hexo框架blog的建立.html":{"url":"content/tools/hexo框架blog的建立.html","title":"hexo框架blog的建立","keywords":"","body":"     配置 hexo 的过程实在不是一个开心的过程，差不过花了一整天，一个周末，就这样莫名其妙的过去了一大半，所以我觉得有必要整理一下自己在这个过程中的探索； 创建 github page Repositories     创建一个 Repositories，必须是 username.github.io 的形式，username 是你的 github 账号用户名，主要起到 github pages 部署 blog 时的识别作用；     然后选择 Repositories 对应的 settings，选择 Choose a theme, 在这一步我们可以下载一个初始的主题，验证一下是否 github pages 已经发布成功！ 生成 SSH 添加到 Github     这一步主要是针对 github 新手而言，以下操作都在 git bash 完成： 设置电脑要关联的 github 账号 git config --global user.name \"yourname\" git config --global user.email \"youremail\" 验证是否设置正确 git config user.name git config user.email 创建 ssh，一路回车 ssh-keygen -t rsa -C \"youremail\"     一般会生成两个文件，id-rsa 和 id_rsa.pub，你只需要把 id_rsa.pub 中的内容加入到 github 账号中去就可以了，具体做法是：登录 web 端的 github 账号后，点击 settings -> SSH keys -> New SSH key, 把 id_rsa.pub 中的内容复制进去即可； 验证是否成功 ssh -T git@github.com     为什么需要 ssh 呢？简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。对于初次在当前电脑使用 github 同步代码，这一步必不可少； Hexo 安装     Hexo 建站当然需要安装 Hexo，要安装 Hexo 那么首先又要安装 npm1，而安装 npm 通常我们通常通过安装 Node.js 环境安装，至于 Node.js 环境安装网上资料多如牛毛，这里就不再具体介绍；以下操作均在终端中进行； npm install -g hexo-cli     这里的-g 是指全局安装，一般情况下，我们在安装了 Node.js 之后，需要设置一个全局安装路径：所有使用 npm 下载的软件包都会下到该路径下，同时该路径也需要加入到环境变量中，这样无论在任一路径下，打开终端，我们都可以使用相应命令； Hexo 建站     在想要建站的目录，打开终端，进行以下操作： hexo init npm install     第一条命令用于建站文件初始化，第二条用于根据 package.json 文件下载建站相关依赖文件； 完成上述操作后，我们基本上就应经获取了就已经获取了如下目录: . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes     _config.yml 用于站点各种信息配置，我们可以在链接中获取详细信息，这里不再赘述；     _post 文件是我们用于存储需要发布 md 文件的目录；     themes 用于存储我们的主题，对于 Hexo 来说，next 模板可能是最常用的了吧，我们只需要下载一套 next 模板，然后放入 thems 目录，同时修改_config.yml 中为 theme: next 即可；     在完成上述操作的情况下，我们基本上已经可以预览一下网站效果了，如果只是预览，那么可以使用： Hexo server     如果想使用调试模式，那么使用： Hexo s --debug     在前述步骤完全配置成功的情况下，那么我们将会看到： INFO Hexo is running at http://localhost:4000 ;     点击对应网址，即可看到效果了； next 模板     关于 next 模板使用的大部分技巧，在这个链接中都可以找到答案，但是这里面提供的 next 下载模板虽然自由度比较大，但是对于那些并不擅长前段开发的人来说，想要快速使用，同时又要保证效果尚佳的人来说，还是有一定难度，所以我推荐使用在 next 模板上已经进行一定程度开发的成熟模板，对于程序员来说这也是一种可以接受的做法：尽量找轮子，而非造轮子；     这是我使用的模板，这个哥们效果做的还是很丰富的，以至于我不得不屏蔽了部分效果；     需要注意的是，对于 next 模板中的大部分文件，我们都是不需要操作的，我们所有需要修改的都可以在该目录下的_config.yml 中完成；     但是也可能存在一些问题，下面是我碰到的一些，以及我所找到的解决方案： 在 next 配置文件中，选择了一些菜单项，例如分类、标签，但是在预览时，点击菜单异常；解决方案 next 模板的网站访问过慢！解决方案 Hexo 部署到 github pages     这里体现了 Jekyll 和 Hexo 一个很大的不同：前者其站点的基础建站文件和 github page 对应的仓库文件是一样的，我们甚至可以修好 md 后直接放到其_post 目录，刷新网页即可看到更新；后者 github page 对应仓库的文件实际是建站文件经过 hexo 编译后上传的文件；     所以对于 Hexo，建议使用两个仓库，一个用于发布 Github pages，另一个则用于同步基础的建站文件，每次建站仓库部署后发布到前者上面；     所以，对于 Hexo 部署，是必不可少的重要一步，操作流程如下： 安装 hexo-deployer-git 部署工具； $ npm install hexo-deployer-git --save     只要执行过一次即可； 修改建站文件中的_config.yml; deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master     要注意，一般必须要求在主分支部署； 部署； hexo clean hexo generate hexo deploy     其中 hexo clean 清除了你之前生成的东西，也可以不加。     hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写；     hexo deploy 部署文章，可以用 hexo d 缩写；     注意 deploy 时可能要你输入 username 和 password，目前发现输慢了可能导致部署失败，所以手速很重要；需要注意的是，该操作尽量在 git bash 中进行，因为 git bash 已经登录了 github 账号，所以要求输入账号密码的可能性不大，如果使用其他终端，则基本上每次都需要输入；     这个步骤在我们每次有新文章同步到 blog 中都需要执行，但是也可以使用简化版： hexo d -g     此时我们可以不用 hexo clean，hexo d -g 会识别增量渲染，不会全部重新生成，感觉更安全一点； 关于 hexo 中的其他问题 hexo 中 markdown 的语法区别； 使用```标记代码块时，后面一个不要加空格，否则代码块范围会识别错误，同时代码最好顶格处理，否则可能会莫名其妙的对不齐； 写脚注时，[^1]：中的冒号必须是中文的，否则显示异常； 在 hexo 中显示图片；   _config.yml 中设置： post_asset_folder: true     使用下述命令创建文章： hexo new [layout]     则会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。这一步也可以手动完成，之后把我们的图片资源放在这个目录下；     使用下述方式引用图片资源： {\\% asset_img 1.jpg \\%}     然后我们就能在 blog 中看到图片的正常显示了；     需要注意的是：这里并不需要我们把资源目录也加进去，因为 hexo 会把这些文件编译后部署到 github pages，如果我们打开目录将会发现图片已经和生成的对应 html 放在同一目录下了； 参考：链接 1 1. 软件包管理器，用于下载一些软件包, 包括 Hexo； ↩ "},"content/tools/Node-js环境的安装与配置.html":{"url":"content/tools/Node-js环境的安装与配置.html","title":"Node-js环境的安装与配置","keywords":"","body":"    Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台, 对于前端开发人员来说基本上必不可少，但对于非前端开发的人员来说就没有那么熟悉了，比如我；但由于某些原因，最近用到了 Node.js 下的 npm 包管理器，所以还是总结一下； Node.js 安装     这一步很简单，基本上没什么坑，如果还不了解的话可以访问地址：Node.js 安装配置； npm 修改全局默认路径     为什么要修改全局默认路径呢？因为 npm 默认下载到 c 盘，如果你不想 c 盘迟早被装满的话，那么最好修改一下全局默认路径；主要分为以下几步： 在 node 目录下建了两个文件夹分别叫 node_global 和 node_cache。同时在 cmd 中运行以下命令： npm config set cache \"D:\\node\\node_cache\" npm config set prefix \"D:\\node\\node_global\" 修改 npm 文件夹下的 npmrc 文件，打开修改里面的内容，原来的内容删掉，写入： prefix=D:\\node\\node_global cache=D:\\node\\node_cache 设置环境变量，主要涉及两个变量： 在用户变量里面新建明为 PATH 的变量，值为 D:\\node\\node_global, 这个值是你在步骤一种新建的文件夹的路径。 在系统变量里面新建一个叫 NODE_PATH 的变量，值为 D:\\node\\node_global\\node_modules     为什么要设置环境变量呢？第一个变量是为了使我们能够在任何时候使用 npm -g 都能定位到该文件夹，第二个是为了任何时候我们使用 npm 下载的管理包都能够被全局识别； "},"content/待处理/原子操作.html":{"url":"content/待处理/原子操作.html","title":"原子操作","keywords":"","body":""}}