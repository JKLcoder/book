{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-C++中的关键字.html":{"url":"content/c++/2020-05-05-C++中的关键字.html","title":"C++中的关键字","keywords":"","body":"const 默认状态下，const对象仅在文件内有效，这和非const对象存在很大不同，也就意味着：如果我们在头文件中包含了一个非cosnt对象，当该头文件被多个文件包含时，将会报出重复定义的错误，但是const对象则不会，我们可以默认其为static对象； 当我们需要多个文件共享同一const变量时，使用头文件固然可以，但更好的做法是：我们在一个文件中定义，而在其它文件中声明；需要注意的是，这里和非const变量也存在不同：非const变量只需要在声明时田间exxtern关键字即可，但是const变量则不管是声明还是定义都要田间extern关键字，我们可以这样理解：在默认const变量为static变量的情况下，我们必须在定义时添加extern关键字才能为其增加外部引用性； const引用及指针不要求其所指向的对象一定是一个常量，其含义仅限于不能通过该指针及引用去改变对象，但是可以通过其它途径； 我们需要区别指针指向常量对象及常量指针，指针指向常量对象意味着不能通过该指针去修改其指向的对象的值，但是可以修改该指针的指向；常量指针则意味着该指针不能修改该指针指向，但是可以通过该指针去修改其所指向对象的值；参考代码 顶层const表示指针本身就是个常量，而底层const表示指针所指向的是一个常量，更一般地说，顶层const可以表示任意的对象是常量，而底层const只存在于指针及引用当中。指针包含了顶层const和底层const，引用的const都是底层const，至于其它的类型则都是顶层const；对于顶层const，其拷贝没有任何影响，也就是说：我们可以把一个顶层const变量拷贝给一个非const变量，反之亦可；但是底层const变量则对此有严格限制：非常量可以拷贝给const变量，反之则不行； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-C++中各种概念对比.html":{"url":"content/c++/2020-05-05-C++中各种概念对比.html","title":"C++中各种概念对比","keywords":"","body":"自定义类 指针与引用的区别 指针是一个对象，而引用是别名，没有空间； 引用必须被初始化，但指针不用； 指针可以修改指向，但是引用不可以； 指针可以指向空，但是引用不可以； sizeof引用我们获得的是所指向对象的大小，而sizeof指针得到的则是指针本身的大小； 内联函数与函数的对比 调用函数一般比较慢：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参； 内联函数避免了函数调用的开销，它将在编译过程中在每个调用点内敛地展开； 总结：如果函数规模较小、流程直接、调用频繁，那么内联函数更好；反之，如果函数规模过大，如果使用内联函数反而会增大exe体积，这种情况则应该使用普通函数； struct和class的区别 struct再第一个访问说明符之前的成员是public，而class再第一个访问说明符之前的成员则是private； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-IO类.html":{"url":"content/c++/2020-05-05-IO类.html","title":"IO类","keywords":"","body":"IO类的基本内容 从上图可以看出，iostream是读写流1，fstream读写文件；从上图可以看出，fstream继承于iostream，因此发fstream也是读写流，只不过它的职责更窄，主要针对文件读写； cin是标准输入流对象，cout是标准输出流对象，这里的标准输入，就是指从键盘输入，标准输出，就是指输出到终端，由于c++中继承机制的实现，使我们不用考虑设备类型和字符大小的问题； c++的输入与输出包括以下三个部分： 对系统制定的标准设备的输入和输出，称为标准I/O（设备）; 以磁盘文件为对象进行输入和输出，称为文件I/O（文件）; 对内存中指定的空间进行输入和输出，称为串I/O（内存）; 关于流的条件状态     一个流一旦发生错误，那么其后续的IO操作都会失败，只有一个流处于无错误状态时，我们才可以对其进行读写操作，因此代码应该在使用一个流之前检查它是否处于良好状态，代码如下： while(cin >> word) //ok: 读操作成功,否则 >>返回false     上面只是告诉了我们流是否有效，例如一个流失败了，我们不知道为什么失败，关于这一部分，我们可以使用iostate2, 也可以使用stream.eof()等函数判断； 关于缓冲区 每个输出流都有一个缓冲区，用来保存程序读写的数据，如果我们执行文本打印操作，那么文本可能立即打印，也可能不立即打印，此时文本就被保存到了缓冲区； 文本缓冲区之所以存在，是因为设备的读写操作可能都很耗时，允许操作系统将多个输出操作合二为一可以带来性能提升； 如果我们不想使用缓冲，那么就必须进行缓冲刷新，以下方式可以导致刷新： 程序正常结束； 缓冲区满时； 使用操作符endl； 使用flush； Note：如果程序崩溃，那么输出缓冲区是不会被刷新的，可能存在这样一种情况：我们通过输出调试信息调试程序，但程序正好崩溃，但实际输出可能已经执行，之所以没有打印只是因为没有缓冲区没有被刷新而已； 文件输入输出     ifstream、ofstream都继承自fstream，分别对应标准输入输出流中的cin、cout，cin是以键盘作为作为标准输入，ifstream是以文件作为输入，换句话说，就是读取文件；同理，cout是以终端作为标准输出，ofstream是以文件作为输出，也就是把数据写入文件； 编写自己的输入输出运算法（14章） 控制输出格式以及文件的随机访问（17章） 1：流是c++中的抽象概念，我们可以认为流就是对象，如果从标准输出输入流中读写数据那么也就意味着从cout、cin中读写数据； 2：iostate是一个机器无关类，提供了表达流状态的完整功能； 参考链接：C++的流 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:52:00 "},"content/c++/2020-05-05-关于数组.html":{"url":"content/c++/2020-05-05-关于数组.html","title":"关于数组","keywords":"","body":"数组声明 数组声明时，我们可以指定其大小，也可以不指定，但后一种情况必须初始化，编译器通过初始化可以确认该数组大小; int a[10] = {1,2,3,4,5}; //正确，数组大小是10 int a[] = {1,2,3,4,5}; //正确，数组大小是5 int a[10]; //正确，数组大小是10 int a[]; //错误，无法确定数组大小 数组大小 int a[] = { 0,1,2,3,4,5,6,7,8,9,2,3,4,5,6}; int x = sizeof(a) / sizeof(a[0]); 数组形参 当数组作为形参时，有两个特殊的性质：不允许拷贝数组、数组将会转化为指针，这也就意味着：当数组已经作为形参传入函数后，已经不能再使用上述sizeof函数的方式来计算数组元素个数了；那么我们此时就必须考虑元素个数的传入问题； void print(const int*);//正确，但无法获知当前数组的元素个数 void print(const int[]);//正确，但无法获知当前数组的元素个数 void print(const int[10]);//正确，同时我们知道了当前数组元素个数为10，但是针对元素个数不为10的数组无法适用 void print(const int*,int n);//这种似乎是最佳方式，适用于任何大小的数组 void print(const int[],int n);//同上 数组作为形参时实际是一个指针，那么如果const修饰该指针那么也就是一个底层const，即无法修改数组中元素； 返回数组 返回指针并不困难，因为指针指向某个地址，地址中存储某个value，但是返回数组却略有不同，因为数组v有大小，那么返回时我们必须考虑同时返回数组的大小，此外，数组不允许拷贝，也就是说我们必须返回数组的指针，这两者导致了在实际操作上存在困难；但是C++还是提供了相应方案，主要分为以下三种： 使用类型别名； 声明一个返回数组指针的函数 使用尾置返回类型 使用decltype 参考代码 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-函数传参.html":{"url":"content/c++/2020-05-05-函数传参.html","title":"函数传参","keywords":"","body":"    函数传参主要分为两种形式：值传递与地址传递；值传递本质上是拷贝，所以无法修改形参；而地址传递传递的是形参本身的地址，因此可以修改形参； 数组传参     数组名其本质是数组的首地址，当我们把数组作为参数传递时，此时属于地址传递； 指针传参     指针传参需要注意的是：指针本身可以视作对象，如果我们要修改其指向，那么就必须进行地址传递，对于指针来说，其地址即对应的二级指针； 可变形参     可变形参主要可以通过两种方式实现： initializer_list 可变参数模板     这两种方式实现可变形参的区别在于：前者必须形参类型都相同，我们可以将其等价于list，只不过与list相比，其缺乏at、[]等访问接口；而可变参数模板则突破了前者这种限制，只不过使用上要稍微复杂一点； 参考代码1参考代码2 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-函数指针.html":{"url":"content/c++/2020-05-05-函数指针.html","title":"函数指针","keywords":"","body":"普通函数指针 函数指针声明 bool lengthCompare(const string&, const string&); bool (*pf)(const string& , const string&) = lengthCompare; pf = lengthCompare; pf = &lengthCompare; bool b = pf(\"hello\", \"goodBye\"); bool b = (*pf)(\"hello\", \"goodBye\"); 注意： 此时的pf表示这是一个函数指针，而非函数指针类型,如果要表示指针类型需要使用指针别名（见下）； 当我们把函数名作为一个值使用时，该函数自动转换为指针； 当我们使用函数指针调用该函数时，无需提前解引用指针； 使用指针别名 typedef bool(*Func)(const string&,const string&); typedef decltype(lengthCompare) *Func; using Func = bool(*)(const string&,const string&); void useBigger(const string& s1, const string& s2, Func f); //将函数指针作为形参 Func f(int); //将函数指针作为返回值 decltype自动类型推导函数后还是函数，一定要加* 使用using定义别名时要注意和typedef存在的区别 尽量定义函数指针别名后再使用函数指针形参及返回，否则会降低代码的可读性 类函数指针 参考代码 使用std::function 和std::bind Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-关于设计模式.html":{"url":"content/c++/2020-05-05-关于设计模式.html","title":"关于设计模式","keywords":"","body":"设计技巧总结 设计任务类 任务类，必须确保一个实例化对象，可以多次执行任务，所以在其构造函数里面，建议不要传参，所有所需参数都可以通过set函数去设置； 因为是一个任务类，所以在执行任务过程中我们无法窥探其中状态，所以必须提供接口可以获取这些状态，例如：是否正在运行、运行是否结束、运行是否成功以及最后的执行结果等； 任务类，必然是耗时的，所以通常与线程相结合，那么就必须考虑，如何取消当前任务的执行； 可以把任务类抽象化，然后再线程中使用队列依次执行，这似乎是一种很好的封装； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/c++/2020-05-05-自定义类.html":{"url":"content/c++/2020-05-05-自定义类.html","title":"自定义类","keywords":"","body":"默认构造函数 如果我们没有显式的定义构造函数，那么编译器将会创建一个默认的构造函数；一旦我们定义了任何构造函数，那么除非我们再定义一个默认构造函数，否则该类讲没有默认构造函数; 默认构造函数与自定义的构造函数似乎没有什么不同，但是实际上还是存在区别，例如类中包含有数组和指针，默认构造函数将会导致野指针等类似问题，此时需要自定义默认构造函数再内部控制对象初始化；这种情况同样可以扩大到类中，如果该类包含其它类，但是其他类没有默认构造函数，为了完成其他类的初始化，那么为该类自定义默认构造函数同样必不可少； 析构函数中的delete[ ] C++中的new相当于C语言中的malloc，如果我们分配一个对象那么就用new char[], 如果要分配一组对象那么就要用new char[n]；但是需要注意的是，前者可以用delete m_data, 也可以用delete [ ]释放空间，但是后者只能用delete [ ]释放空间，如果用delete释放new [ ]分配的空间，那么将会只释放第一个，从而导致内存泄漏；基于上述原因，所以我们一律使用delete[ ]在析构函数中释放分配的空间； 赋值函数 赋值函数返回引用；当我们给一个值赋值时，只有返回其本身引用才有意义，否则如果返回一个新的变量，那么将会毫无意义； 自我判断；赋值时无法避免把自己赋给自己，所以必须在函数内部加以判断； 释放原有空间，分配新的空间 ；为什么不在原有空间上赋值，而必须销毁之前的，再创建一个新的呢？首先无法确保原有空间是否足够，其次就算足够那么我们也会浪费空间； 拷贝构造函数 拷贝构造函数分浅拷贝与深拷贝：浅拷贝仅复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，而深拷贝会另外创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会修改原对象；如果一个类里有指针，那么则必须对该指针进行深拷贝，反之，浅拷贝即可满足条件； 运算符重载与友元函数 为什么在可以使用类成员函数进行运算符重载的情况下，还要使用友元函数进行运算符重载，这是因为可能存在下列情况：A = B*2.75; 那么这个对应的是A = B.operaotr(2.75); 那么反过来呢？A=2.75\\B；由于2.75并非对象，那么这种情况就无法成立，在此基础上，所以需要使用友元函数进行运算符重载；针对A=2.75*B就可以和class1 operator*(double m，const class1 &t)进行匹配；对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。 友元函数需要注意他的作用域；如果一个友元函数在类中声明，在类外定义，那么这种情况是没有问题的；但是如果一个友元函数在类中定义呢？那么此时友元函数变成了一个内联函数，但是需要注意的是，由于此时其在外部未被声明，那么无论在类内部还是外部都不能被调用； struct X{ friend void f(){} X(f(); ) //错误：f还没有被声明 void g(); void h(); }; void X::g(){return f(); } //错误：f还没有被声明 void f(); void X:h(){return f(); } //正确，f已经被声明了 友元类 友元类可以类比友元函数，一个类的友元类可以访问此类中包括非公有成员在内的所有成员； class Screen{ friend class Window_mgr; } 参考代码 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "},"content/tools/2020-05-25-hexo框架blog的建立.html":{"url":"content/tools/2020-05-25-hexo框架blog的建立.html","title":"hexo框架blog的建立","keywords":"","body":"    之前使用过csdn写过blog，但是之前自己糟糕的排版，渐渐打消了我坚持下去的动力，直到最近，开始使用vscode，然后又学了一下markdown，才让我产生了重新开始写blog的想法；     一开始选用了Jekyll，但是Jekyll框架下实在很难找到一个吸引人的主题，之前做了一个，但感觉实在很一般，于是开始使用hexo；     配置hexo的过程实在不是一个开心的过程，差不过花了一整天，一个周末，就这样莫名其妙的过去了一大半，所以我觉得有必要整理一下自己在这个过程中的探索； 创建github page Repositories     创建一个Repositories，必须是username.github.io的形式，username是你的github账号用户名，主要起到github pages部署blog时的识别作用；     然后选择Repositories对应的settings，选择Choose a theme, 在这一步我们可以下载一个初始的主题，验证一下是否github pages已经发布成功！ 生成SSH添加到Github     这一步主要是针对github新手而言，以下操作都在git bash完成： 设置电脑要关联的github账号 git config --global user.name \"yourname\" git config --global user.email \"youremail\" 验证是否设置正确 git config user.name git config user.email 创建ssh，一路回车 ssh-keygen -t rsa -C \"youremail\"     一般会生成两个文件，id-rsa和id_rsa.pub，你只需要把id_rsa.pub中的内容加入到github账号中去就可以了，具体做法是：登录web端的github账号后，点击settings -> SSH keys -> New SSH key, 把id_rsa.pub中的内容复制进去即可； 验证是否成功 ssh -T git@github.com     为什么需要ssh呢？简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。对于初次在当前电脑使用github同步代码，这一步必不可少； Hexo安装     Hexo建站当然需要安装Hexo，要安装Hexo那么首先又要安装npm1，而安装npm通常我们通常通过安装Node.js环境安装，至于Node.js环境安装网上资料多如牛毛，这里就不再具体介绍；以下操作均在终端中进行； npm install -g hexo-cli     这里的-g是指全局安装，一般情况下，我们在安装了Node.js之后，需要设置一个全局安装路径：所有使用npm下载的软件包都会下到该路径下，同时该路径也需要加入到环境变量中，这样无论在任一路径下，打开终端，我们都可以使用相应命令； Hexo建站     在想要建站的目录，打开终端，进行以下操作： hexo init npm install     第一条命令用于建站文件初始化，第二条用于根据package.json文件下载建站相关依赖文件； 完成上述操作后，我们基本上就应经获取了就已经获取了如下目录: . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes     _config.yml用于站点各种信息配置，我们可以在链接中获取详细信息，这里不再赘述；     _post文件是我们用于存储需要发布md文件的目录；     themes用于存储我们的主题，对于Hexo来说，next模板可能是最常用的了吧，我们只需要下载一套next模板，然后放入thems目录，同时修改_config.yml中为theme: next即可；     在完成上述操作的情况下，我们基本上已经可以预览一下网站效果了，如果只是预览，那么可以使用： Hexo server     如果想使用调试模式，那么使用： Hexo s --debug     在前述步骤完全配置成功的情况下，那么我们将会看到： INFO Hexo is running at http://localhost:4000 ;     点击对应网址，即可看到效果了； next模板     关于next模板使用的大部分技巧，在这个链接中都可以找到答案，但是这里面提供的next下载模板虽然自由度比较大，但是对于那些并不擅长前段开发的人来说，想要快速使用，同时又要保证效果尚佳的人来说，还是有一定难度，所以我推荐使用在next模板上已经进行一定程度开发的成熟模板，对于程序员来说这也是一种可以接受的做法：尽量找轮子，而非造轮子；     这是我使用的模板，这个哥们效果做的还是很丰富的，以至于我不得不屏蔽了部分效果；     需要注意的是，对于next模板中的大部分文件，我们都是不需要操作的，我们所有需要修改的都可以在该目录下的_config.yml中完成；     但是也可能存在一些问题，下面是我碰到的一些，以及我所找到的解决方案： 在next配置文件中，选择了一些菜单项，例如分类、标签，但是在预览时，点击菜单异常；解决方案 next模板的网站访问过慢！解决方案 Hexo部署到github pages     这里体现了Jekyll和Hexo一个很大的不同：前者其站点的基础建站文件和github page对应的仓库文件是一样的，我们甚至可以修好md后直接放到其_post目录，刷新网页即可看到更新；后者github page对应仓库的文件实际是建站文件经过hexo编译后上传的文件；     所以对于Hexo，建议使用两个仓库，一个用于发布Github pages，另一个则用于同步基础的建站文件，每次建站仓库部署后发布到前者上面；     所以，对于Hexo部署，是必不可少的重要一步，操作流程如下： 安装hexo-deployer-git部署工具； $ npm install hexo-deployer-git --save     只要执行过一次即可； 修改建站文件中的_config.yml; deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master     要注意，一般必须要求在主分支部署； 部署； hexo clean hexo generate hexo deploy     其中 hexo clean清除了你之前生成的东西，也可以不加。     hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写；     hexo deploy 部署文章，可以用hexo d缩写；     注意deploy时可能要你输入username和password，目前发现输慢了可能导致部署失败，所以手速很重要；需要注意的是，该操作尽量在git bash中进行，因为git bash已经登录了github账号，所以要求输入账号密码的可能性不大，如果使用其他终端，则基本上每次都需要输入；     这个步骤在我们每次有新文章同步到blog中都需要执行，但是也可以使用简化版： hexo d -g     此时我们可以不用hexo clean，hexo d -g会识别增量渲染，不会全部重新生成，感觉更安全一点； 关于hexo中的其他问题 hexo中markdown的语法区别； 使用```标记代码块时，后面一个不要加空格，否则代码块范围会识别错误，同时代码最好顶格处理，否则可能会莫名其妙的对不齐； 写脚注时，[^1]：中的冒号必须是中文的，否则显示异常； 在hexo中显示图片；     _config.yml中设置： post_asset_folder: true     使用下述命令创建文章： hexo new [layout]     则会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。这一步也可以手动完成，之后把我们的图片资源放在这个目录下；     使用下述方式引用图片资源： {\\% asset_img 1.jpg \\%}     然后我们就能在blog中看到图片的正常显示了；     需要注意的是：这里并不需要我们把资源目录也加进去，因为hexo会把这些文件编译后部署到github pages，如果我们打开目录将会发现图片已经和生成的对应html放在同一目录下了； 参考：链接1 1. 软件包管理器，用于下载一些软件包, 包括Hexo； ↩ Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 23:12:34 "},"content/tools/2020-05-25-Node-js环境的安装与配置.html":{"url":"content/tools/2020-05-25-Node-js环境的安装与配置.html","title":"js环境的安装与配置","keywords":"","body":"    Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台, 对于前端开发人员来说基本上必不可少，但对于非前端开发的人员来说就没有那么熟悉了，比如我；但由于某些原因，最近用到了Node.js下的npm包管理器，所以还是总结一下； Node.js安装     这一步很简单，基本上没什么坑，如果还不了解的话可以访问地址：Node.js 安装配置； npm修改全局默认路径     为什么要修改全局默认路径呢？因为npm默认下载到c盘，如果你不想c盘迟早被装满的话，那么最好修改一下全局默认路径；主要分为以下几步： 在node目录下建了两个文件夹分别叫node_global和node_cache。同时在cmd中运行以下命令： npm config set cache \"D:\\node\\node_cache\" npm config set prefix \"D:\\node\\node_global\" 修改npm文件夹下的npmrc文件，打开修改里面的内容，原来的内容删掉，写入： prefix=D:\\node\\node_global cache=D:\\node\\node_cache 设置环境变量，主要涉及两个变量： 在用户变量里面新建明为PATH的变量，值为D:\\node\\node_global, 这个值是你在步骤一种新建的文件夹的路径。 在系统变量里面新建一个叫NODE_PATH的变量，值为D:\\node\\node_global\\node_modules     为什么要设置环境变量呢？第一个变量是为了使我们能够在任何时候使用 npm -g 都能定位到该文件夹，第二个是为了任何时候我们使用npm下载的管理包都能够被全局识别； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-27 22:17:50 "}}