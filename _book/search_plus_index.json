{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介    Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:45:59 "},"content/c++/C++中各种概念对比.html":{"url":"content/c++/C++中各种概念对比.html","title":"C++中各种概念对比","keywords":"","body":"指针与引用的区别 指针是一个对象，而引用是别名，没有空间； 引用必须被初始化，但指针不用； 指针可以修改指向，但是引用不可以； 指针可以指向空，但是引用不可以； sizeof 引用我们获得的是所指向对象的大小，而 sizeof 指针得到的则是指针本身的大小； 内联函数与函数的对比 调用函数一般比较慢：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参； 内联函数避免了函数调用的开销，它将在编译过程中在每个调用点内敛地展开； 总结：如果函数规模较小、流程直接、调用频繁，那么内联函数更好；反之，如果函数规模过大，如果使用内联函数反而会增大 exe 体积，这种情况则应该使用普通函数； struct 和 class 的区别 struct 再第一个访问说明符之前的成员是 public，而 class 再第一个访问说明符之前的成员则是 private； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:56:39 "},"content/c++/C++中的关键字.html":{"url":"content/c++/C++中的关键字.html","title":"C++中的关键字","keywords":"","body":"const 默认状态下，const 对象仅在文件内有效，这和非 const 对象存在很大不同，也就意味着：如果我们在头文件中包含了一个非 cosnt 对象，当该头文件被多个文件包含时，将会报出重复定义的错误，但是 const 对象则不会，我们可以默认其为 static 对象； 当我们需要多个文件共享同一 const 变量时，使用头文件固然可以，但更好的做法是：我们在一个文件中定义，而在其它文件中声明；需要注意的是，这里和非 const 变量也存在不同：非 const 变量只需要在声明时田间 exxtern 关键字即可，但是 const 变量则不管是声明还是定义都要田间 extern 关键字，我们可以这样理解：在默认 const 变量为 static 变量的情况下，我们必须在定义时添加 extern 关键字才能为其增加外部引用性； const 引用及指针不要求其所指向的对象一定是一个常量，其含义仅限于不能通过该指针及引用去改变对象，但是可以通过其它途径； 我们需要区别指针指向常量对象及常量指针，指针指向常量对象意味着不能通过该指针去修改其指向的对象的值，但是可以修改该指针的指向；常量指针则意味着该指针不能修改该指针指向，但是可以通过该指针去修改其所指向对象的值；参考代码 顶层 const 表示指针本身就是个常量，而底层 const 表示指针所指向的是一个常量，更一般地说，顶层 const 可以表示任意的对象是常量，而底层 const 只存在于指针及引用当中。指针包含了顶层 const 和底层 const，引用的 const 都是底层 const，至于其它的类型则都是顶层 const；对于顶层 const，其拷贝没有任何影响，也就是说：我们可以把一个顶层 const 变量拷贝给一个非 const 变量，反之亦可；但是底层 const 变量则对此有严格限制：非常量可以拷贝给 const 变量，反之则不行； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:56:15 "},"content/c++/IO类.html":{"url":"content/c++/IO类.html","title":"IO类","keywords":"","body":"IO 类的基本内容 从上图可以看出，iostream 是读写流1，fstream 读写文件；从上图可以看出，fstream 继承于 iostream，因此发 fstream 也是读写流，只不过它的职责更窄，主要针对文件读写； cin 是标准输入流对象，cout 是标准输出流对象，这里的标准输入，就是指从键盘输入，标准输出，就是指输出到终端，由于 c++中继承机制的实现，使我们不用考虑设备类型和字符大小的问题； c++的输入与输出包括以下三个部分： 对系统制定的标准设备的输入和输出，称为标准 I/O（设备）; 以磁盘文件为对象进行输入和输出，称为文件 I/O（文件）; 对内存中指定的空间进行输入和输出，称为串 I/O（内存）; 关于流的条件状态   一个流一旦发生错误，那么其后续的 IO 操作都会失败，只有一个流处于无错误状态时，我们才可以对其进行读写操作，因此代码应该在使用一个流之前检查它是否处于良好状态，代码如下： while(cin >> word) //ok: 读操作成功,否则 >>返回false   上面只是告诉了我们流是否有效，例如一个流失败了，我们不知道为什么失败，关于这一部分，我们可以使用 iostate2, 也可以使用 stream.eof()等函数判断； 关于缓冲区 每个输出流都有一个缓冲区，用来保存程序读写的数据，如果我们执行文本打印操作，那么文本可能立即打印，也可能不立即打印，此时文本就被保存到了缓冲区； 文本缓冲区之所以存在，是因为设备的读写操作可能都很耗时，允许操作系统将多个输出操作合二为一可以带来性能提升； 如果我们不想使用缓冲，那么就必须进行缓冲刷新，以下方式可以导致刷新： 程序正常结束； 缓冲区满时； 使用操作符 endl； 使用 flush； Note：如果程序崩溃，那么输出缓冲区是不会被刷新的，可能存在这样一种情况：我们通过输出调试信息调试程序，但程序正好崩溃，但实际输出可能已经执行，之所以没有打印只是因为没有缓冲区没有被刷新而已； 文件输入输出   ifstream、ofstream 都继承自 fstream，分别对应标准输入输出流中的 cin、cout，cin 是以键盘作为作为标准输入，ifstream 是以文件作为输入，换句话说，就是读取文件；同理，cout 是以终端作为标准输出，ofstream 是以文件作为输出，也就是把数据写入文件;代码链接 文件模式   在使用过程中，文件模式需要注意一下几点： 只可以对 ofstream 和 fstream 设定 out 模式，只可以对 ifstream 和 fstream 设定 in 模式，那么如果我们需要同时对文件进行镀锡，需要创建 fstream 对象； 当写文件时，文件默认为 trunc 模式，文件一旦打开，就会立即清空，如果我们想要追加数据，而不是覆盖，那么需要同时制定 app 模式，这样数据会被追加到文件末尾； 编写自己的输入输出运算法（14 章） 控制输出格式以及文件的随机访问（17 章） 1：流是 c++中的抽象概念，我们可以认为流就是对象，如果从标准输出输入流中读写数据那么也就意味着从 cout、cin 中读写数据； 2：iostate 是一个机器无关类，提供了表达流状态的完整功能； 参考链接：C++的流 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:56:47 "},"content/c++/关于数组.html":{"url":"content/c++/关于数组.html","title":"关于数组","keywords":"","body":"数组声明 数组声明时，我们可以指定其大小，也可以不指定，但后一种情况必须初始化，编译器通过初始化可以确认该数组大小; int a[10] = {1,2,3,4,5}; //正确，数组大小是10 int a[] = {1,2,3,4,5}; //正确，数组大小是5 int a[10]; //正确，数组大小是10 int a[]; //错误，无法确定数组大小 数组大小 int a[] = { 0,1,2,3,4,5,6,7,8,9,2,3,4,5,6}; int x = sizeof(a) / sizeof(a[0]); 数组形参 当数组作为形参时，有两个特殊的性质：不允许拷贝数组、数组将会转化为指针，这也就意味着：当数组已经作为形参传入函数后，已经不能再使用上述sizeof函数的方式来计算数组元素个数了；那么我们此时就必须考虑元素个数的传入问题； void print(const int*);//正确，但无法获知当前数组的元素个数 void print(const int[]);//正确，但无法获知当前数组的元素个数 void print(const int[10]);//正确，同时我们知道了当前数组元素个数为10，但是针对元素个数不为10的数组无法适用 void print(const int*,int n);//这种似乎是最佳方式，适用于任何大小的数组 void print(const int[],int n);//同上 数组作为形参时实际是一个指针，那么如果const修饰该指针那么也就是一个底层const，即无法修改数组中元素； 返回数组 返回指针并不困难，因为指针指向某个地址，地址中存储某个value，但是返回数组却略有不同，因为数组v有大小，那么返回时我们必须考虑同时返回数组的大小，此外，数组不允许拷贝，也就是说我们必须返回数组的指针，这两者导致了在实际操作上存在困难；但是C++还是提供了相应方案，主要分为以下三种： 使用类型别名； 声明一个返回数组指针的函数 使用尾置返回类型 使用decltype 参考代码 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 09:11:08 "},"content/c++/函数传参.html":{"url":"content/c++/函数传参.html","title":"函数传参","keywords":"","body":"    函数传参主要分为两种形式：值传递与地址传递；值传递本质上是拷贝，所以无法修改形参；而地址传递传递的是形参本身的地址，因此可以修改形参； 数组传参     数组名其本质是数组的首地址，当我们把数组作为参数传递时，此时属于地址传递； 指针传参     指针传参需要注意的是：指针本身可以视作对象，如果我们要修改其指向，那么就必须进行地址传递，对于指针来说，其地址即对应的二级指针； 可变形参     可变形参主要可以通过两种方式实现： initializer_list 可变参数模板     这两种方式实现可变形参的区别在于：前者必须形参类型都相同，我们可以将其等价于list，只不过与list相比，其缺乏at、[]等访问接口；而可变参数模板则突破了前者这种限制，只不过使用上要稍微复杂一点； 参考代码1参考代码2 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 09:11:08 "},"content/c++/函数指针.html":{"url":"content/c++/函数指针.html","title":"函数指针","keywords":"","body":"普通函数指针 函数指针声明 bool lengthCompare(const string&, const string&); bool (*pf)(const string& , const string&) = lengthCompare; pf = lengthCompare; pf = &lengthCompare; bool b = pf(\"hello\", \"goodBye\"); bool b = (*pf)(\"hello\", \"goodBye\"); 注意： 此时的pf表示这是一个函数指针，而非函数指针类型,如果要表示指针类型需要使用指针别名（见下）； 当我们把函数名作为一个值使用时，该函数自动转换为指针； 当我们使用函数指针调用该函数时，无需提前解引用指针； 使用指针别名 typedef bool(*Func)(const string&,const string&); typedef decltype(lengthCompare) *Func; using Func = bool(*)(const string&,const string&); void useBigger(const string& s1, const string& s2, Func f); //将函数指针作为形参 Func f(int); //将函数指针作为返回值 decltype自动类型推导函数后还是函数，一定要加* 使用using定义别名时要注意和typedef存在的区别 尽量定义函数指针别名后再使用函数指针形参及返回，否则会降低代码的可读性 类函数指针 参考代码 使用std::function 和std::bind Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 09:11:08 "},"content/c++/智能指针.html":{"url":"content/c++/智能指针.html","title":"智能指针","keywords":"","body":"Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:58:46 "},"content/c++/自定义类.html":{"url":"content/c++/自定义类.html","title":"自定义类","keywords":"","body":"默认构造函数 如果我们没有显式的定义构造函数，那么编译器将会创建一个默认的构造函数；一旦我们定义了任何构造函数，那么除非我们再定义一个默认构造函数，否则该类讲没有默认构造函数; 默认构造函数与自定义的构造函数似乎没有什么不同，但是实际上还是存在区别，例如类中包含有数组和指针，默认构造函数将会导致野指针等类似问题，此时需要自定义默认构造函数再内部控制对象初始化；这种情况同样可以扩大到类中，如果该类包含其它类，但是其他类没有默认构造函数，为了完成其他类的初始化，那么为该类自定义默认构造函数同样必不可少； 析构函数中的 delete[ ] C++中的 new 相当于 C 语言中的 malloc，如果我们分配一个对象那么就用 new char[], 如果要分配一组对象那么就要用 new char[n]；但是需要注意的是，前者可以用 delete m_data, 也可以用 delete [ ]释放空间，但是后者只能用 delete [ ]释放空间，如果用 delete 释放 new [ ]分配的空间，那么将会只释放第一个，从而导致内存泄漏；基于上述原因，所以我们一律使用 delete[ ]在析构函数中释放分配的空间； 赋值函数 赋值函数返回引用；当我们给一个值赋值时，只有返回其本身引用才有意义，否则如果返回一个新的变量，那么将会毫无意义； 自我判断；赋值时无法避免把自己赋给自己，所以必须在函数内部加以判断； 释放原有空间，分配新的空间 ；为什么不在原有空间上赋值，而必须销毁之前的，再创建一个新的呢？首先无法确保原有空间是否足够，其次就算足够那么我们也会浪费空间； 拷贝构造函数 拷贝构造函数分浅拷贝与深拷贝：浅拷贝仅复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，而深拷贝会另外创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不会修改原对象；如果一个类里有指针，那么则必须对该指针进行深拷贝，反之，浅拷贝即可满足条件； 运算符重载与友元函数 为什么在可以使用类成员函数进行运算符重载的情况下，还要使用友元函数进行运算符重载，这是因为可能存在下列情况：A = B*2.75; 那么这个对应的是 A = B.operaotr*(2.75); 那么反过来呢？A=2.75*B；由于 2.75 并非对象，那么这种情况就无法成立，在此基础上，所以需要使用友元函数进行运算符重载；针对 A=2.75*B 就可以和 class1 operator*(double m，const class1 &t)进行匹配；对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。 友元函数需要注意他的作用域；如果一个友元函数在类中声明，在类外定义，那么这种情况是没有问题的；但是如果一个友元函数在类中定义呢？那么此时友元函数变成了一个内联函数，但是需要注意的是，由于此时其在外部未被声明，那么无论在类内部还是外部都不能被调用； struct X{ friend void f(){} X(f(); ) //错误：f还没有被声明 void g(); void h(); }; void X::g(){return f(); } //错误：f还没有被声明 void f(); void X:h(){return f(); } //正确，f已经被声明了 友元类 友元类可以类比友元函数，一个类的友元类可以访问此类中包括非公有成员在内的所有成员； class Screen{ friend class Window_mgr; } 参考代码 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:55:40 "},"content/JavaScript/JavaScript基础知识.html":{"url":"content/JavaScript/JavaScript基础知识.html","title":"JavaScript基础知识","keywords":"","body":"Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 09:11:08 "},"content/Qt/Qt中异常问题集锦.html":{"url":"content/Qt/Qt中异常问题集锦.html","title":"Qt中异常问题集锦","keywords":"","body":" 中文读写乱码 中文读写乱码   设置本地编码为 utf-8 即可，如下： QTextCodec::setCodecForLocale(QTextCodec::codecForName(\"Utf-8\")); Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:31:03 "},"content/Qt/Qt代码片段集锦.html":{"url":"content/Qt/Qt代码片段集锦.html","title":"Qt代码片段集锦","keywords":"","body":" 递归遍历目录 递归遍历目录 //参数含义（当前遍历目录、当前遍历目录上一级目录name、记录当前目录相对于顶级父目录深度） bool reverseDir(const QDir& dir,QString parentName,int parentLevel) { QString dirname = parentName + QString(\"%1/\").arg(dir.dirName()); parentLevel++; QFileInfoList list = dir.entryInfoList(); for(QFileInfo &info : list) { //在Qt10.1中发现，如果不过滤将会有这两个目录，可以认为是父目录和二级父目录，如果遍历当前目录则必须过滤掉 if(!QString::compare(info.fileName(),\".\") || !QString::compare(info.fileName(),\"..\")) continue; if(info.isDir()) //当前为目录 { ... reverseDir(QDir(info.filePath()),dirname,parentLevel,in); } else //当前为文件 { ... } } return 1; } Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:41:06 "},"content/tools/2020-05-25-hexo框架blog的建立.html":{"url":"content/tools/2020-05-25-hexo框架blog的建立.html","title":"2020-05-25-hexo框架blog的建立","keywords":"","body":"    之前使用过 csdn 写过 blog，但是之前自己糟糕的排版，渐渐打消了我坚持下去的动力，直到最近，开始使用 vscode，然后又学了一下 markdown，才让我产生了重新开始写 blog 的想法；    一开始选用了 Jekyll，但是 Jekyll 框架下实在很难找到一个吸引人的主题，之前做了一个，但感觉实在很一般，于是开始使用 hexo；    配置 hexo 的过程实在不是一个开心的过程，差不过花了一整天，一个周末，就这样莫名其妙的过去了一大半，所以我觉得有必要整理一下自己在这个过程中的探索； 创建 github page Repositories     创建一个 Repositories，必须是 username.github.io 的形式，username 是你的 github 账号用户名，主要起到 github pages 部署 blog 时的识别作用；     然后选择 Repositories 对应的 settings，选择 Choose a theme, 在这一步我们可以下载一个初始的主题，验证一下是否 github pages 已经发布成功！ 生成 SSH 添加到 Github     这一步主要是针对 github 新手而言，以下操作都在 git bash 完成： 设置电脑要关联的 github 账号 git config --global user.name \"yourname\" git config --global user.email \"youremail\" 验证是否设置正确 git config user.name git config user.email 创建 ssh，一路回车 ssh-keygen -t rsa -C \"youremail\"     一般会生成两个文件，id-rsa 和 id_rsa.pub，你只需要把 id_rsa.pub 中的内容加入到 github 账号中去就可以了，具体做法是：登录 web 端的 github 账号后，点击 settings -> SSH keys -> New SSH key, 把 id_rsa.pub 中的内容复制进去即可； 验证是否成功 ssh -T git@github.com     为什么需要 ssh 呢？简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。对于初次在当前电脑使用 github 同步代码，这一步必不可少； Hexo 安装     Hexo 建站当然需要安装 Hexo，要安装 Hexo 那么首先又要安装 npm1，而安装 npm 通常我们通常通过安装 Node.js 环境安装，至于 Node.js 环境安装网上资料多如牛毛，这里就不再具体介绍；以下操作均在终端中进行； npm install -g hexo-cli     这里的-g 是指全局安装，一般情况下，我们在安装了 Node.js 之后，需要设置一个全局安装路径：所有使用 npm 下载的软件包都会下到该路径下，同时该路径也需要加入到环境变量中，这样无论在任一路径下，打开终端，我们都可以使用相应命令； Hexo 建站     在想要建站的目录，打开终端，进行以下操作： hexo init npm install     第一条命令用于建站文件初始化，第二条用于根据 package.json 文件下载建站相关依赖文件； 完成上述操作后，我们基本上就应经获取了就已经获取了如下目录: . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes     _config.yml 用于站点各种信息配置，我们可以在链接中获取详细信息，这里不再赘述；     _post 文件是我们用于存储需要发布 md 文件的目录；     themes 用于存储我们的主题，对于 Hexo 来说，next 模板可能是最常用的了吧，我们只需要下载一套 next 模板，然后放入 thems 目录，同时修改_config.yml 中为 theme: next 即可；     在完成上述操作的情况下，我们基本上已经可以预览一下网站效果了，如果只是预览，那么可以使用： Hexo server     如果想使用调试模式，那么使用： Hexo s --debug     在前述步骤完全配置成功的情况下，那么我们将会看到： INFO Hexo is running at http://localhost:4000 ;     点击对应网址，即可看到效果了； next 模板     关于 next 模板使用的大部分技巧，在这个链接中都可以找到答案，但是这里面提供的 next 下载模板虽然自由度比较大，但是对于那些并不擅长前段开发的人来说，想要快速使用，同时又要保证效果尚佳的人来说，还是有一定难度，所以我推荐使用在 next 模板上已经进行一定程度开发的成熟模板，对于程序员来说这也是一种可以接受的做法：尽量找轮子，而非造轮子；     这是我使用的模板，这个哥们效果做的还是很丰富的，以至于我不得不屏蔽了部分效果；     需要注意的是，对于 next 模板中的大部分文件，我们都是不需要操作的，我们所有需要修改的都可以在该目录下的_config.yml 中完成；     但是也可能存在一些问题，下面是我碰到的一些，以及我所找到的解决方案： 在 next 配置文件中，选择了一些菜单项，例如分类、标签，但是在预览时，点击菜单异常；解决方案 next 模板的网站访问过慢！解决方案 Hexo 部署到 github pages     这里体现了 Jekyll 和 Hexo 一个很大的不同：前者其站点的基础建站文件和 github page 对应的仓库文件是一样的，我们甚至可以修好 md 后直接放到其_post 目录，刷新网页即可看到更新；后者 github page 对应仓库的文件实际是建站文件经过 hexo 编译后上传的文件；     所以对于 Hexo，建议使用两个仓库，一个用于发布 Github pages，另一个则用于同步基础的建站文件，每次建站仓库部署后发布到前者上面；     所以，对于 Hexo 部署，是必不可少的重要一步，操作流程如下： 安装 hexo-deployer-git 部署工具； $ npm install hexo-deployer-git --save     只要执行过一次即可； 修改建站文件中的_config.yml; deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master     要注意，一般必须要求在主分支部署； 部署； hexo clean hexo generate hexo deploy     其中 hexo clean 清除了你之前生成的东西，也可以不加。     hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写；     hexo deploy 部署文章，可以用 hexo d 缩写；     注意 deploy 时可能要你输入 username 和 password，目前发现输慢了可能导致部署失败，所以手速很重要；需要注意的是，该操作尽量在 git bash 中进行，因为 git bash 已经登录了 github 账号，所以要求输入账号密码的可能性不大，如果使用其他终端，则基本上每次都需要输入；     这个步骤在我们每次有新文章同步到 blog 中都需要执行，但是也可以使用简化版： hexo d -g     此时我们可以不用 hexo clean，hexo d -g 会识别增量渲染，不会全部重新生成，感觉更安全一点； 关于 hexo 中的其他问题 hexo 中 markdown 的语法区别； 使用```标记代码块时，后面一个不要加空格，否则代码块范围会识别错误，同时代码最好顶格处理，否则可能会莫名其妙的对不齐； 写脚注时，[^1]：中的冒号必须是中文的，否则显示异常； 在 hexo 中显示图片；     _config.yml 中设置： post_asset_folder: true     使用下述命令创建文章： hexo new [layout]     则会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。这一步也可以手动完成，之后把我们的图片资源放在这个目录下；     使用下述方式引用图片资源： {\\% asset_img 1.jpg \\%}     然后我们就能在 blog 中看到图片的正常显示了；     需要注意的是：这里并不需要我们把资源目录也加进去，因为 hexo 会把这些文件编译后部署到 github pages，如果我们打开目录将会发现图片已经和生成的对应 html 放在同一目录下了； 参考：链接 1 1. 软件包管理器，用于下载一些软件包, 包括 Hexo； ↩ Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:57:01 "},"content/tools/hexo框架blog的建立.html":{"url":"content/tools/hexo框架blog的建立.html","title":"hexo框架blog的建立","keywords":"","body":"    之前使用过 csdn 写过 blog，但是之前自己糟糕的排版，渐渐打消了我坚持下去的动力，直到最近，开始使用 vscode，然后又学了一下 markdown，才让我产生了重新开始写 blog 的想法；     一开始选用了 Jekyll，但是 Jekyll 框架下实在很难找到一个吸引人的主题，之前做了一个，但感觉实在很一般，于是开始使用 hexo；     配置 hexo 的过程实在不是一个开心的过程，差不过花了一整天，一个周末，就这样莫名其妙的过去了一大半，所以我觉得有必要整理一下自己在这个过程中的探索； 创建 github page Repositories     创建一个 Repositories，必须是 username.github.io 的形式，username 是你的 github 账号用户名，主要起到 github pages 部署 blog 时的识别作用；     然后选择 Repositories 对应的 settings，选择 Choose a theme, 在这一步我们可以下载一个初始的主题，验证一下是否 github pages 已经发布成功！ 生成 SSH 添加到 Github     这一步主要是针对 github 新手而言，以下操作都在 git bash 完成： 设置电脑要关联的 github 账号 git config --global user.name \"yourname\" git config --global user.email \"youremail\" 验证是否设置正确 git config user.name git config user.email 创建 ssh，一路回车 ssh-keygen -t rsa -C \"youremail\"     一般会生成两个文件，id-rsa 和 id_rsa.pub，你只需要把 id_rsa.pub 中的内容加入到 github 账号中去就可以了，具体做法是：登录 web 端的 github 账号后，点击 settings -> SSH keys -> New SSH key, 把 id_rsa.pub 中的内容复制进去即可； 验证是否成功 ssh -T git@github.com     为什么需要 ssh 呢？简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。对于初次在当前电脑使用 github 同步代码，这一步必不可少； Hexo 安装     Hexo 建站当然需要安装 Hexo，要安装 Hexo 那么首先又要安装 npm1，而安装 npm 通常我们通常通过安装 Node.js 环境安装，至于 Node.js 环境安装网上资料多如牛毛，这里就不再具体介绍；以下操作均在终端中进行； npm install -g hexo-cli     这里的-g 是指全局安装，一般情况下，我们在安装了 Node.js 之后，需要设置一个全局安装路径：所有使用 npm 下载的软件包都会下到该路径下，同时该路径也需要加入到环境变量中，这样无论在任一路径下，打开终端，我们都可以使用相应命令； Hexo 建站     在想要建站的目录，打开终端，进行以下操作： hexo init npm install     第一条命令用于建站文件初始化，第二条用于根据 package.json 文件下载建站相关依赖文件； 完成上述操作后，我们基本上就应经获取了就已经获取了如下目录: . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes     _config.yml 用于站点各种信息配置，我们可以在链接中获取详细信息，这里不再赘述；     _post 文件是我们用于存储需要发布 md 文件的目录；     themes 用于存储我们的主题，对于 Hexo 来说，next 模板可能是最常用的了吧，我们只需要下载一套 next 模板，然后放入 thems 目录，同时修改_config.yml 中为 theme: next 即可；     在完成上述操作的情况下，我们基本上已经可以预览一下网站效果了，如果只是预览，那么可以使用： Hexo server     如果想使用调试模式，那么使用： Hexo s --debug     在前述步骤完全配置成功的情况下，那么我们将会看到： INFO Hexo is running at http://localhost:4000 ;     点击对应网址，即可看到效果了； next 模板     关于 next 模板使用的大部分技巧，在这个链接中都可以找到答案，但是这里面提供的 next 下载模板虽然自由度比较大，但是对于那些并不擅长前段开发的人来说，想要快速使用，同时又要保证效果尚佳的人来说，还是有一定难度，所以我推荐使用在 next 模板上已经进行一定程度开发的成熟模板，对于程序员来说这也是一种可以接受的做法：尽量找轮子，而非造轮子；     这是我使用的模板，这个哥们效果做的还是很丰富的，以至于我不得不屏蔽了部分效果；     需要注意的是，对于 next 模板中的大部分文件，我们都是不需要操作的，我们所有需要修改的都可以在该目录下的_config.yml 中完成；     但是也可能存在一些问题，下面是我碰到的一些，以及我所找到的解决方案： 在 next 配置文件中，选择了一些菜单项，例如分类、标签，但是在预览时，点击菜单异常；解决方案 next 模板的网站访问过慢！解决方案 Hexo 部署到 github pages     这里体现了 Jekyll 和 Hexo 一个很大的不同：前者其站点的基础建站文件和 github page 对应的仓库文件是一样的，我们甚至可以修好 md 后直接放到其_post 目录，刷新网页即可看到更新；后者 github page 对应仓库的文件实际是建站文件经过 hexo 编译后上传的文件；     所以对于 Hexo，建议使用两个仓库，一个用于发布 Github pages，另一个则用于同步基础的建站文件，每次建站仓库部署后发布到前者上面；     所以，对于 Hexo 部署，是必不可少的重要一步，操作流程如下： 安装 hexo-deployer-git 部署工具； $ npm install hexo-deployer-git --save     只要执行过一次即可； 修改建站文件中的_config.yml; deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master     要注意，一般必须要求在主分支部署； 部署； hexo clean hexo generate hexo deploy     其中 hexo clean 清除了你之前生成的东西，也可以不加。     hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写；     hexo deploy 部署文章，可以用 hexo d 缩写；     注意 deploy 时可能要你输入 username 和 password，目前发现输慢了可能导致部署失败，所以手速很重要；需要注意的是，该操作尽量在 git bash 中进行，因为 git bash 已经登录了 github 账号，所以要求输入账号密码的可能性不大，如果使用其他终端，则基本上每次都需要输入；     这个步骤在我们每次有新文章同步到 blog 中都需要执行，但是也可以使用简化版： hexo d -g     此时我们可以不用 hexo clean，hexo d -g 会识别增量渲染，不会全部重新生成，感觉更安全一点； 关于 hexo 中的其他问题 hexo 中 markdown 的语法区别； 使用```标记代码块时，后面一个不要加空格，否则代码块范围会识别错误，同时代码最好顶格处理，否则可能会莫名其妙的对不齐； 写脚注时，[^1]：中的冒号必须是中文的，否则显示异常； 在 hexo 中显示图片；   _config.yml 中设置： post_asset_folder: true     使用下述命令创建文章： hexo new [layout]     则会自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。这一步也可以手动完成，之后把我们的图片资源放在这个目录下；     使用下述方式引用图片资源： {\\% asset_img 1.jpg \\%}     然后我们就能在 blog 中看到图片的正常显示了；     需要注意的是：这里并不需要我们把资源目录也加进去，因为 hexo 会把这些文件编译后部署到 github pages，如果我们打开目录将会发现图片已经和生成的对应 html 放在同一目录下了； 参考：链接 1 1. 软件包管理器，用于下载一些软件包, 包括 Hexo； ↩ Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:57:11 "},"content/tools/Node-js环境的安装与配置.html":{"url":"content/tools/Node-js环境的安装与配置.html","title":"Node-js环境的安装与配置","keywords":"","body":"    Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台, 对于前端开发人员来说基本上必不可少，但对于非前端开发的人员来说就没有那么熟悉了，比如我；但由于某些原因，最近用到了 Node.js 下的 npm 包管理器，所以还是总结一下； Node.js 安装     这一步很简单，基本上没什么坑，如果还不了解的话可以访问地址：Node.js 安装配置； npm 修改全局默认路径     为什么要修改全局默认路径呢？因为 npm 默认下载到 c 盘，如果你不想 c 盘迟早被装满的话，那么最好修改一下全局默认路径；主要分为以下几步： 在 node 目录下建了两个文件夹分别叫 node_global 和 node_cache。同时在 cmd 中运行以下命令： npm config set cache \"D:\\node\\node_cache\" npm config set prefix \"D:\\node\\node_global\" 修改 npm 文件夹下的 npmrc 文件，打开修改里面的内容，原来的内容删掉，写入： prefix=D:\\node\\node_global cache=D:\\node\\node_cache 设置环境变量，主要涉及两个变量： 在用户变量里面新建明为 PATH 的变量，值为 D:\\node\\node_global, 这个值是你在步骤一种新建的文件夹的路径。 在系统变量里面新建一个叫 NODE_PATH 的变量，值为 D:\\node\\node_global\\node_modules     为什么要设置环境变量呢？第一个变量是为了使我们能够在任何时候使用 npm -g 都能定位到该文件夹，第二个是为了任何时候我们使用 npm 下载的管理包都能够被全局识别； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-29 14:57:18 "}}