{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-26 10:57:33 "},"content/section1/2020-05-05-C++中的关键字.html":{"url":"content/section1/2020-05-05-C++中的关键字.html","title":"第一章","keywords":"","body":"const 默认状态下，const对象仅在文件内有效，这和非const对象存在很大不同，也就意味着：如果我们在头文件中包含了一个非cosnt对象，当该头文件被多个文件包含时，将会报出重复定义的错误，但是const对象则不会，我们可以默认其为static对象； 当我们需要多个文件共享同一const变量时，使用头文件固然可以，但更好的做法是：我们在一个文件中定义，而在其它文件中声明；需要注意的是，这里和非const变量也存在不同：非const变量只需要在声明时田间exxtern关键字即可，但是const变量则不管是声明还是定义都要田间extern关键字，我们可以这样理解：在默认const变量为static变量的情况下，我们必须在定义时添加extern关键字才能为其增加外部引用性； const引用及指针不要求其所指向的对象一定是一个常量，其含义仅限于不能通过该指针及引用去改变对象，但是可以通过其它途径； 我们需要区别指针指向常量对象及常量指针，指针指向常量对象意味着不能通过该指针去修改其指向的对象的值，但是可以修改该指针的指向；常量指针则意味着该指针不能修改该指针指向，但是可以通过该指针去修改其所指向对象的值；参考代码 顶层const表示指针本身就是个常量，而底层const表示指针所指向的是一个常量，更一般地说，顶层const可以表示任意的对象是常量，而底层const只存在于指针及引用当中。指针包含了顶层const和底层const，引用的const都是底层const，至于其它的类型则都是顶层const；对于顶层const，其拷贝没有任何影响，也就是说：我们可以把一个顶层const变量拷贝给一个非const变量，反之亦可；但是底层const变量则对此有严格限制：非常量可以拷贝给const变量，反之则不行； Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-25 11:07:23 "},"content/section1/2020-05-05-函数指针.html":{"url":"content/section1/2020-05-05-函数指针.html","title":"第一节","keywords":"","body":"普通函数指针 函数指针声明 bool lengthCompare(const string&, const string&); bool (*pf)(const string& , const string&) = lengthCompare; pf = lengthCompare; pf = &lengthCompare; bool b = pf(\"hello\", \"goodBye\"); bool b = (*pf)(\"hello\", \"goodBye\"); 注意： 此时的pf表示这是一个函数指针，而非函数指针类型,如果要表示指针类型需要使用指针别名（见下）； 当我们把函数名作为一个值使用时，该函数自动转换为指针； 当我们使用函数指针调用该函数时，无需提前解引用指针； 使用指针别名 typedef bool(*Func)(const string&,const string&); typedef decltype(lengthCompare) *Func; using Func = bool(*)(const string&,const string&); void useBigger(const string& s1, const string& s2, Func f); //将函数指针作为形参 Func f(int); //将函数指针作为返回值 decltype自动类型推导函数后还是函数，一定要加* 使用using定义别名时要注意和typedef存在的区别 尽量定义函数指针别名后再使用函数指针形参及返回，否则会降低代码的可读性 类函数指针 参考代码 使用std::function 和std::bind Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-25 11:06:54 "},"content/section1/2020-05-05-函数传参.html":{"url":"content/section1/2020-05-05-函数传参.html","title":"第二节","keywords":"","body":"    函数传参主要分为两种形式：值传递与地址传递；值传递本质上是拷贝，所以无法修改形参；而地址传递传递的是形参本身的地址，因此可以修改形参； 数组传参     数组名其本质是数组的首地址，当我们把数组作为参数传递时，此时属于地址传递； 指针传参     指针传参需要注意的是：指针本身可以视作对象，如果我们要修改其指向，那么就必须进行地址传递，对于指针来说，其地址即对应的二级指针； 可变形参     可变形参主要可以通过两种方式实现： initializer_list 可变参数模板     这两种方式实现可变形参的区别在于：前者必须形参类型都相同，我们可以将其等价于list，只不过与list相比，其缺乏at、[]等访问接口；而可变参数模板则突破了前者这种限制，只不过使用上要稍微复杂一点； 参考代码1参考代码2 Copyright © Kevin.top 2019 all right reserved，powered by Gitbook改文件修订时间 2020-05-25 11:06:47 "}}